(self.webpackChunkdoc_ops=self.webpackChunkdoc_ops||[]).push([[341],{3905:function(e,a,t){"use strict";t.d(a,{Zo:function(){return p},kt:function(){return h}});var n=t(7294);function i(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function o(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);a&&(n=n.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,n)}return t}function s(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?o(Object(t),!0).forEach((function(a){i(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}function r(e,a){if(null==e)return{};var t,n,i=function(e,a){if(null==e)return{};var t,n,i={},o=Object.keys(e);for(n=0;n<o.length;n++)t=o[n],a.indexOf(t)>=0||(i[t]=e[t]);return i}(e,a);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)t=o[n],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var l=n.createContext({}),d=function(e){var a=n.useContext(l),t=a;return e&&(t="function"==typeof e?e(a):s(s({},a),e)),t},p=function(e){var a=d(e.components);return n.createElement(l.Provider,{value:a},e.children)},c={inlineCode:"code",wrapper:function(e){var a=e.children;return n.createElement(n.Fragment,{},a)}},m=n.forwardRef((function(e,a){var t=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,p=r(e,["components","mdxType","originalType","parentName"]),m=d(t),h=i,u=m["".concat(l,".").concat(h)]||m[h]||c[h]||o;return t?n.createElement(u,s(s({ref:a},p),{},{components:t})):n.createElement(u,s({ref:a},p))}));function h(e,a){var t=arguments,i=a&&a.mdxType;if("string"==typeof e||i){var o=t.length,s=new Array(o);s[0]=m;var r={};for(var l in a)hasOwnProperty.call(a,l)&&(r[l]=a[l]);r.originalType=e,r.mdxType="string"==typeof e?e:i,s[1]=r;for(var d=2;d<o;d++)s[d]=t[d];return n.createElement.apply(null,s)}return n.createElement.apply(null,t)}m.displayName="MDXCreateElement"},3248:function(e,a,t){"use strict";t.r(a),t.d(a,{frontMatter:function(){return r},contentTitle:function(){return l},metadata:function(){return d},toc:function(){return p},default:function(){return m}});var n=t(2122),i=t(9756),o=(t(7294),t(3905)),s=["components"],r={},l="5.3 Mana",d={unversionedId:"5.3 Mana",id:"5.3 Mana",isDocsHomePage:!1,title:"5.3 Mana",description:"5.3.1 Introduction",source:"@site/docs/5.3 Mana.md",sourceDirName:".",slug:"/5.3 Mana",permalink:"/IOTA-2.0-Research-Specifications/docs/5.3 Mana",editUrl:"https://github.com/iotaledger/IOTA-2.0-Research-Specifications/edit/master/website/docs/5.3 Mana.md",version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"5.2 Ledger State",permalink:"/IOTA-2.0-Research-Specifications/docs/5.2 Ledger State"},next:{title:"6.1 Objects of Consensus",permalink:"/IOTA-2.0-Research-Specifications/docs/6.1 Objects of Consensus"}},p=[{value:"5.3.1 Introduction",id:"531-introduction",children:[]},{value:"5.3.2. Detailed Design - General",id:"532-detailed-design---general",children:[]},{value:"5.3.3 Detailed Design - Consensus Mana",id:"533-detailed-design---consensus-mana",children:[{value:"5.3.3.1 Consensus Mana update procedure",id:"5331-consensus-mana-update-procedure",children:[]},{value:"5.3.3.2 Active Consensus Mana and Epochs",id:"5332-active-consensus-mana-and-epochs",children:[]}]},{value:"5.3.4 Detailed Design - Access Mana",id:"534-detailed-design---access-mana",children:[{value:"5.3.4.1 Access Mana update procedure",id:"5341-access-mana-update-procedure",children:[]}]},{value:"5.3.5. Initialization",id:"535-initialization",children:[]},{value:"5.3.6. Algorithm",id:"536-algorithm",children:[{value:"5.3.6.1. Parameter Values",id:"5361-parameter-values",children:[]},{value:"5.3.6.2. Local Variables and Built-in Functions",id:"5362-local-variables-and-built-in-functions",children:[]}]},{value:"5.3.6.3. Pseudocode - cMana Update",id:"5363-pseudocode---cmana-update",children:[{value:"5.3.6.4. Pseudocode - aMana Update",id:"5364-pseudocode---amana-update",children:[]}]}],c={toc:p};function m(e){var a=e.components,t=(0,i.Z)(e,s);return(0,o.kt)("wrapper",(0,n.Z)({},c,t,{components:a,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"53-mana"},"5.3 Mana"),(0,o.kt)("h2",{id:"531-introduction"},"5.3.1 Introduction"),(0,o.kt)("p",null,"This section introduces  ",(0,o.kt)("em",{parentName:"p"},"access Mana")," and ",(0,o.kt)("em",{parentName:"p"},"consensus Mana")," and determines which modules use each of these two types of Mana."),(0,o.kt)("p",null,"Any permissionless system needs a Sybil protection mechanism. In Coordicide, this is done by forcing every node to create a node identity (see also ","[Section 3.3 - Peer Discovery]","(./2.1 Peer Discovery.md)). Since the creation of an arbitrarily large number of identities is not an expensive operation, two ",(0,o.kt)("em",{parentName:"p"},"Difficult-to-obtain")," resources are linked to each node identity; we call them ",(0,o.kt)("em",{parentName:"p"},"access Mana"),"(",(0,o.kt)("strong",{parentName:"p"},"aMana"),") and ",(0,o.kt)("em",{parentName:"p"},"consensus Mana")," (",(0,o.kt)("strong",{parentName:"p"},"cMana"),"). Both kinds of Mana can be described as essential resources to multiple parts of the network. They are related to the IOTA token, but are not tokens by themselves "," and do not interfere with the token balance in any direct way. When a transaction is processed, a certain amount of aMana and cMana\u2014dependent on the amount of IOTAs moved by the transaction\u2014will be pledged to nodes specified in the transaction (their node IDs must be specified as defined in ","[Section 2.2 - Standard Payloads Layout]","(./2.2 Standard Payloads Layout.md)). The access and consensus Mana pledged to each node ID must be stored as an extension of the ledger state. The only way a node can obtain aMana or cMana is to convince some ken holders to pledge to it. Both kinds of Mana provides adequate Sybil protection because they are difficult and costly to be acquired in arbitrarily large amounts.  "),(0,o.kt)("p",null,"Access and consensus Mana are used as Sybil protection in different modules, which have different natures and requirements. For this reason, it is natural to use different formulas to calculate the appropriate Mana to each module. Consensus Mana should be seen as the Mana that is responsible for the security of the system, on the other hand, access Mana is used to distribute access to the network during congestion periods."),(0,o.kt)("p",null,"We give a short overview on how each module uses its associated kind of Mana:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"[Section 3.4 - Neighbor Selection]","(./3.4 Neighbor Selection.md):  Nodes only establish a connection with nodes of similar consensus Mana."),(0,o.kt)("li",{parentName:"ul"},"[Section 4.6 - Congestion Control]","(./4.6 Congestion Control.md): The throughput (in bytes per second) of each node is dependent on the access Mana held."),(0,o.kt)("li",{parentName:"ul"},"[Section 6.3 -  Fast Probabilistic Consensus]","(./6.3 Fast Probabilistic Consensus.md): The selection probability for a node during a voting query is proportional to the consensus Mana held."),(0,o.kt)("li",{parentName:"ul"},"[Section 6.4 - Finalization]","(./6.4 Finalization.md): Finalization occurs when (among other criteria) a message is approved by nodes holding a certain fraction of the consensus Mana in the network."),(0,o.kt)("li",{parentName:"ul"},"[Section 6.6 - Distributed Random Number Generator]","(./6.6 dRNG.md): The dRNG committee members must be composed by high consensus Mana nodes.")),(0,o.kt)("p",null,"The Mana specification depends on the following specification:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"[4.2 - Timestamps]","(./4.2 Timestamps.md)")),(0,o.kt)("h2",{id:"532-detailed-design---general"},"5.3.2. Detailed Design - General"),(0,o.kt)("p",null,"Each transaction must have an ",(0,o.kt)("inlineCode",{parentName:"p"},"accessManaNodeID")," and a ",(0,o.kt)("inlineCode",{parentName:"p"},"consensusManaNodeID")," field to determine which node to pledge these two types of Mana. Both of these fields consist of a node ID of the node that will receive each kind of Mana. Access Mana and consensus Mana do not have to be pledged to the same node."),(0,o.kt)("p",null,"Both kinds of Mana are ",(0,o.kt)("em",{parentName:"p"},"exponential moving averages")," (EMA) of the ",(0,o.kt)("em",{parentName:"p"},"base Manas")," (specifically, cMana is the EMA of base cMana, and aMana is the EMA of base aMana). An EMA is a type of moving average that places a greater weight and significance on the most recent data points. More precisely, the weighting for older data decreases exponentially in time, however, never reaching zero.  "," "),(0,o.kt)("p",null,"Even though the definition of an EMA should be unique (no matter to which function that you apply it), the general algorithm for the calculation of the EMAs\u2014with the flexibility needed in our case\u2014is not easily implementable. Thus, two different algorithms already customized for each type of Mana are provided in the present document."),(0,o.kt)("p",null,"We define the following parameters:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"$\\gamma$- decay factor for base aMana."),(0,o.kt)("li",{parentName:"ul"},"$\\alpha$- moving average factor for the cMana. "),(0,o.kt)("li",{parentName:"ul"},"$\\beta$- moving average factor for the aMana. ")),(0,o.kt)("p",null,"Additionally, we define four vectors that assign a real value to each node Id: the ",(0,o.kt)("em",{parentName:"p"},"aMana vector"),", ",(0,o.kt)("em",{parentName:"p"},"base aMana vector"),", ",(0,o.kt)("em",{parentName:"p"},"cMana vector")," and base ",(0,o.kt)("em",{parentName:"p"},"cMana vector"),". The base aMana vector and the base cMana vector are auxiliary vectors (meaning that they are needed to compute the aMana vector and the cMana vector, even though their values are not directly used in any of the modules). Due to the time dependance of the EMA (and also the base aMana function), the four vectors have a ",(0,o.kt)("em",{parentName:"p"},"reference time")," to which they are associated."),(0,o.kt)("p",null,"The Mana vectors are updated in different occasions. Access Mana pledging happens when a transaction is booked on the ledger state. At the same time, entries of the nodes whose aMana is not being modified during the pledging are updated only with respect to the (possibly) newer time reference. In general, updates only due to time (without aMana pledging) happen whenever a node's aMana is being accessed by an external module (as the congestion control, for instance). "),(0,o.kt)("p",null,"On the other hand, cMana is updated only relatively to the end of each epoch (see ","[Section 4.2 - Timestamps]","(./4.2 Timestamps.md)). The reason behind this is that epochs are objective, i.e. all nodes agree on which epoch a certain message (or transaction) belongs to. Thus, since nodes agree (with high probability) about transactions with timestamps older than the end of the epoch plus ",(0,o.kt)("inlineCode",{parentName:"p"},"TIMESTAMP_CUTOFF")," (see ","[Section 4.2 - Timestamps]","(./4.2 Timestamps.md)), they will consequently agree\u2014again, with high probability\u2013about the cMana vector relative to these transactions. "),(0,o.kt)("p",null,"Therefore, one can assume that the nodes in sync will (with high probability) agree on values of cMana relative to the set of transactions that have timestamp older than a fixed epoch in the past. On the other hand, aMana will capture recent fluctuations, but nodes are expected to have slightly different perceptions of this quantity."),(0,o.kt)("h2",{id:"533-detailed-design---consensus-mana"},"5.3.3 Detailed Design - Consensus Mana"),(0,o.kt)("p",null,"The base cMana of a node ",(0,o.kt)("inlineCode",{parentName:"p"},"nodeID")," at time ",(0,o.kt)("inlineCode",{parentName:"p"},"time")," is defined as the sum over all unspent outputs at time ",(0,o.kt)("inlineCode",{parentName:"p"},"time")," of transactions  with  ",(0,o.kt)("inlineCode",{parentName:"p"},"consensusManaNodeID = nodeID"),". This means that, when an output is consumed, its cMana pledge is revoked and pledged to a (possibly) different node. See the example below: "),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Example 1:")),(0,o.kt)("p",null,"Suppose transaction $z$ was booked and we want to update the base cMana vector accordingly. Additionally, suppose transaction $z$, $x$ and $y$ pledges cMana to nodes $N_z$,  $N_x$ and $N_y$, respectively."),(0,o.kt)("img",{src:"https://github.com/iotaledger/Coordicide-Specifications/blob/section/mana/images/cmana.png"}),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Image 5.3.1:")," Illustration of outputs being consumed."),(0,o.kt)("p",null,"The update of the base cMana proceeds as follows: "),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Add 300 to the base cMana state of the node $N_z$."),(0,o.kt)("li",{parentName:"ol"},"Subtract 100 from the base cMana state of the node $N_x$."),(0,o.kt)("li",{parentName:"ol"},"Subtract 200 from the base cMana state of the node $N_y$.")),(0,o.kt)("p",null,"If a transaction $T_i$ with timestamp $t_i$ pledges $M_i$ cMana to a node $Z$, then the cMana evolution over time relative to this transaction will be given by:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"$$\n\\text{cMana}_Z^{T_i}(t) = \\begin{cases}\n        0, \\text{ if } t< t_i \\\\\n        M_i\\left(1-e^{-\\alpha (t-t_i)}\\right), \\text{ if } t\\geq t_i  \\\\\n\\end{cases}\n$$\n")),(0,o.kt)("p",null,"The total cMana of a node $Z$ will be, then, given by the sum of $\\text{cMana}_Z^{T_i}(t)$ among all the transactions $T_i$ that pledge cMana to node $Z$. Nevertheless, computing the mana using this equation may be excessively demanding in the case where a node has multiples pledges at different times. For that reason, the cMana shall be computed recursively, updating it based on its last value. This update is customized for three different situations (here, $t_0$ is the reference time of the previous cMana value):"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"pledging of the cMana relative to a transaction with timestamp smaller than $t_0$.  "),(0,o.kt)("li",{parentName:"ol"},"pledging of the cMana relative to a transaction with timestamp larger than $t_0$.  "),(0,o.kt)("li",{parentName:"ol"},"updating the cMana to a time $t_1>t_0$ without any new cMana pledging.")),(0,o.kt)("p",null,"In the first case, the reference time of the cMana must not be changed, whereas in the second case, the reference time of the cMana must be changed to the timestamp of the transaction. This means that a node must never update the cMana to a point in the past (relatively to the last cMana calculated). The exact update procedure for each of the cases defined above are defined next."),(0,o.kt)("h3",{id:"5331-consensus-mana-update-procedure"},"5.3.3.1 Consensus Mana update procedure"),(0,o.kt)("h4",{id:"pledging-the-cmana-relative-to-a-transaction-with-timestamp-smaller-than-the-last-reference-time"},"Pledging the cMana relative to a transaction with timestamp smaller than the last reference time"),(0,o.kt)("p",null,"Suppose that the last reference time is $t$ and the transaction timestamp is $t-s$. The update must be done in two steps, always in the order specified below:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("em",{parentName:"p"},"a"),") ",(0,o.kt)("strong",{parentName:"p"},"Base cMana update"),". Just before updating the base cMana vector we must store it, since the last base cMana state (that we call $\\text{Old","_","Base","_","cMana}$) and the time relative to the last update are used later for the cMana calculations. This temporary vector can be deleted right after the cMana vector is updated."),(0,o.kt)("p",{parentName:"li"},"  The update of the base cMana state goes as follows: if a new transaction with $n$ inputs of values $x_1, x_2, \\ldots, x_n$ pledges cMana to a node $N$, then"),(0,o.kt)("ol",{parentName:"li"},(0,o.kt)("li",{parentName:"ol"},"we add $\\sum_{j=1}^{n}x_j$ to the base cMana of the node $N$."),(0,o.kt)("li",{parentName:"ol"},"Each input $I_j$ corresponds to some UTXO (and, consequently, to some transaction) stored in the ledger state. Then, we locate the node Id (let us say, $\\text{Node}_j$) to whom the cMana relative to this output was pledged to in the past. Then, we subtract $x_j$ from the base cMana state of the node $\\text{Node}_j$, for each $I_j$, $j=1,\\dots,n$."))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("em",{parentName:"p"},"b"),") ",(0,o.kt)("strong",{parentName:"p"},"Pledging and revoking cMana"),". If the base cMana balance of node $i$ (before we added this transaction) was $\\text{Old","_","Base","_","cMana}(\\text{Node}_i)$ and the new base cMana balance (after the addition of this transaction) is $\\text{Base","_","cMana}(\\text{Node}_i)$, then we update the cMana vector adding to all nodes' entry the term:"))),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"    $$\n    (1-e^{-\\alpha s})[\\text{Base\\_cMana}(\\text{Node}_i)-\\text{Old\\_Base\\_cMana}(\\text{Node}_i)]\n    $$\n\n    The term above can be negative\u2014since some nodes have their base cMana revoked\u2014but the resulting cMana must not be. Notice that for most nodes (specifically, for all nodes that did not have their base cMana value changed) the value above is zero.\n")),(0,o.kt)("h4",{id:"pledging-the-cmana-relative-to-a-transaction-with-timestamp-larger-than-the-last-reference-time"},"Pledging the cMana relative to a transaction with timestamp larger than the last reference time"),(0,o.kt)("p",null,"Suppose that the last reference time is $t-s$ and the transaction timestamp is $t$. The update must be done in two steps, always in the order specified below:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("em",{parentName:"p"},"a"),") ",(0,o.kt)("strong",{parentName:"p"},"Base cMana update"),". Just before updating the base cMana vector we must store it, since the last base cMana state (that we call $\\text{Old","_","Base","_","cMana}$) and the time relative to the last update are used later for the cMana calculations. This temporary vector can be deleted right after the cMana vector is updated."),(0,o.kt)("p",{parentName:"li"},"  The update of the base cMana state goes as follows: if a new transaction with $n$ inputs of respective values $x_1, x_2, \\ldots, x_n$ pledges cMana to a node $N$, then"),(0,o.kt)("ol",{parentName:"li"},(0,o.kt)("li",{parentName:"ol"},"we add $\\sum_{j=1}^{n}x_j$ to the base cMana of the node $N$."),(0,o.kt)("li",{parentName:"ol"},"Each input $I_j$ corresponds to some UTXO (and, consequently, to some transaction) stored in the ledger state. Then, we locate the node Id (let us say, $\\text{Node}_j$) to whom the cMana relative to this output was pledged to in the past. Then, we subtract $x_j$ from the base cMana state of the node $\\text{Node}_j$, for each $I_j$, $j=1,\\dots,n$."))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("em",{parentName:"p"},"b"),") ",(0,o.kt)("strong",{parentName:"p"},"Updating the cMana with respect to time"),". Suppose that the outdated cMana is $\\text{Old","_","cMana}$. We update all cMana entries as follows:"))),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"    $$\n    \\text{cMana}(\\text{Node}_i)=e^{-\\alpha s} \\text{Old\\_cMana}(\\text{Node}_i)+(1-e^{-\\alpha s})\\text{Old\\_Base\\_cMana}(\\text{Node}_i)\n    $$\n    where $\\alpha$ is the moving average parameter for the cMana. \n")),(0,o.kt)("h4",{id:"updating-the-cmana-to-a-time-larger-than-the-last-reference-time-without-any-new-cmana-pledging"},"Updating the cMana to a time larger than the last reference time without any new cMana pledging"),(0,o.kt)("p",null,"Suppose that the last reference time is $t-s$, the new one is $t$ and the last cMana vector is $\\text{Old","_","cMana}$. We update all cMana entries as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"    $$\n    \\text{cMana}(\\text{Node}_i)=e^{-\\alpha s} \\text{Old\\_cMana}(\\text{Node}_i)+(1-e^{-\\alpha s})\\text{Old\\_Base\\_cMana}(\\text{Node}_i)\n    $$\n    where $\\alpha$ is the moving average parameter for the cMana. \n")),(0,o.kt)("h3",{id:"5332-active-consensus-mana-and-epochs"},"5.3.3.2 Active Consensus Mana and Epochs"),(0,o.kt)("p",null,"The consensus Mana of a node is only calculated and stored relatively to the end of each epoch (see ","[Section 4.2 - Timestamps]","(./4.2 Timestamps.md)). Only the values of the last ",(0,o.kt)("inlineCode",{parentName:"p"},"MAX_STORED_EPOCHS")," epochs are stored. Thus, if $t_E$ is the time of the end of epoch $E$, to update the cMana vector from epoch $E-1$ to $E$, a node must perform the following algorithm:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Update the cMana with respect to time, as described in section 4.3.3.1.3, from time $t",(0,o.kt)("em",{parentName:"p"},"{E-1}$ to $t"),"{E}$")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"For each transaction with timestamp in the interval $[t",(0,o.kt)("em",{parentName:"p"},"{E-1},t"),"{E})$, perform (as described in section 4.3.3.1.1) the base cMana update and the pledge and revoking of cMana, while the reference time $t_{E}$ remains constant."))),(0,o.kt)("p",null,"Additionally, we define the ",(0,o.kt)("em",{parentName:"p"},"active consensus Mana")," of a node A in epoch E (i.e., relatively to time $t",(0,o.kt)("em",{parentName:"p"},"{E}$) as (here, $\\text{cMana}$ is also relative to time $t"),"{E}$):"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"$$\n\\text{Active\\_cMana}(\\text{Node A})=\\begin{cases}\n\\text{cMana}(\\text{Node A}), \\text{ if there is at least one message from node `node` with timestamp in }[t_{E-1},t_{E}) \\\\\n0, \\text{ otherwise}\n\\end{cases}\n$$\n")),(0,o.kt)("p",null,"Therefore, even if node ",(0,o.kt)("inlineCode",{parentName:"p"},"node")," has consensus Mana greater than zero at a certain epoch $E$, it can be considered dormant in case it did not issue any message during the same epoch. All nodes that have active consensus Mana in epoch $E$ will form what we call the active consensus Mana set of that epoch, or ",(0,o.kt)("inlineCode",{parentName:"p"},"ACMS(E)"),"."),(0,o.kt)("p",null,"Both calculations defined above (cMana and active cMana on an epoch $E$) can only be carried out when epoch $E$ is finalized\u2014that is, at least ",(0,o.kt)("inlineCode",{parentName:"p"},"TIMESTAMP_CUTOFF")," (see ","[Section 4.2 - Timestamps]","(./4.2 Timestamps.md)) units of time after $t_E$\u2014to make sure that no more messages belonging to the epoch will appear in the network."),(0,o.kt)("p",null,"The following data structures and functions must be defined:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"UpdatecMana(epoch)"),": updates the base cMana and cMana vectors from the end of ",(0,o.kt)("inlineCode",{parentName:"p"},"epoch-1")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"epoch"),", pledging and revoking the base cMana and cMana relative to all the relevant transactions. ")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"GetActiveConsensusMana(time)"),": returns a mapping between all known nodes and their active cMana, calculated at the end of the epoch that contains ",(0,o.kt)("inlineCode",{parentName:"p"},"time"),".")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"ManaRank(lowerMana, upperMana, epoch)"),": returns the node ID of the nodes with active cMana in the interval ",(0,o.kt)("inlineCode",{parentName:"p"},"[lowerMana, upperMana]"),", relative to ",(0,o.kt)("inlineCode",{parentName:"p"},"epoch"),". Notice that ",(0,o.kt)("inlineCode",{parentName:"p"},"epoch")," must be, at least, the current epoch minus ",(0,o.kt)("inlineCode",{parentName:"p"},"MAX_STORED_EPOCHS")," and, at most, the last epoch."))),(0,o.kt)("h2",{id:"534-detailed-design---access-mana"},"5.3.4 Detailed Design - Access Mana"),(0,o.kt)("p",null,"When an output is consumed and funds are consequently transferred, a certain amount of base aMana\u2014dependent on the amount of funds and the age of the output\u2014will be pledged to a node. This pledge is never revoked, as opposed to base cMana. Nevertheless, the base aMana of all nodes will ",(0,o.kt)("em",{parentName:"p"},"decay")," over time, which means that all the calculations for aMana will be slightly different than for cMana. The base aMana at time $t$, relative to an output $T_i$ (of amount $M_i$) consumed by a transaction with timestamp $t-s$ and generated by a transaction with timestamp $t-s-\\delta$ is, for $s,\\delta>0$"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"$$\n  \\text{Base\\_aMana}^{T_i}(t)= M (1-e^{-\\gamma \\delta}) e^{-\\gamma s}, \\text{ if } t\\geq t-s\n$$ \n")),(0,o.kt)("p",null,"If this same output pledges aMana to a node $Z$, then the aMana evolution over time (again, for $s,\\delta>0$) relative to it will be given by:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"$$\n\\text{aMana}_Z^{T_i}(t) = \\begin{cases}\n        M_i(1-e^{-\\gamma\\delta})\\dfrac{\\beta e^{-\\beta s}}{\\beta-\\gamma}\\left(e^{(\\beta-\\gamma)s}-1\\right), \\text{ if }\\beta\\neq \\gamma\\\\\n        M_i(1-e^{-\\gamma\\delta})\\gamma s e^{-\\gamma s}, \\text{ if } \\beta= \\gamma\\\\\n\\end{cases}\n$$\n")),(0,o.kt)("p",null,"The base aMana of a node ",(0,o.kt)("inlineCode",{parentName:"p"},"nodeID")," at time ",(0,o.kt)("inlineCode",{parentName:"p"},"time")," is defined as the sum of the individual base aMana generated by all already consumed outputs $T_i$ of transactions  with  ",(0,o.kt)("inlineCode",{parentName:"p"},"accessManaNodeID = nodeID")," and timestamp smaller or equal than ",(0,o.kt)("inlineCode",{parentName:"p"},"time"),". Nevertheless, as in the cMana case, computing the aMana using this equation can be excessively demanding. For that reason, the aMana shall computed recursively, updating it based on its last value. This update is customized for three different situations (here, $t_0$ is the reference time of the last aMana value):"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"pledging of the aMana relative to a transaction with timestamp smaller than $t_0$;"),(0,o.kt)("li",{parentName:"ol"},"pledging of the aMana relative to a transaction with timestamp larger than $t_0$;"),(0,o.kt)("li",{parentName:"ol"},"updating the aMana to a time $t_1>t_0$ without any new aMana pledging.")),(0,o.kt)("p",null,"In the first case, the reference time of the aMana must not be changed, whereas in the second case, the reference time of the cMana must be changed to the timestamp of the transaction. This means that a node must never update the aMana to a point in the past (relatively to the last aMana calculated). The exact update procedure for each of the cases defined above are defined next."),(0,o.kt)("h3",{id:"5341-access-mana-update-procedure"},"5.3.4.1 Access Mana update procedure"),(0,o.kt)("h4",{id:"pledging-the-amana-relative-to-a-transaction-with-timestamp-smaller-than-the-last-reference-time"},"Pledging the aMana relative to a transaction with timestamp smaller than the last reference time"),(0,o.kt)("p",null,"Suppose that the last reference time is $t$ and the transaction timestamp is $t-s$. The update must be done in two steps, always in the order specified below:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Base aMana pledging"),". Suppose that the new transaction consists of $m$ inputs $I_1, I_2, \\ldots, I_m$ of value $x_1, x_2, \\ldots, x_m$\u2014respectively\u2014and pledges aMana to a node $N$. We update the base aMana of node $N$ by adding to its base aMana the value")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"    $$\n    d=e^{-\\gamma s} \\sum_{j=1}^{m}x_j(1-e^{-\\gamma \\delta_{j}})\n    $$ \n    where $\\delta_{j}>0$ is the difference between $t$ and the timestamps of the transaction that generated $I_j$ and $\\gamma$ is the decay factor. This value $d$ has to be temporarily stored, since it will be used in the aMana update.\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Pledging aMana"),". We update the aMana vector adding to node $N$'s entry the term:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"    $$\n    \\begin{cases}  \n    \\frac{e^{-\\gamma s}-e^{-\\beta s}}{(\\beta-\\gamma)e^{-\\gamma s}}\\beta d,\\text{ if }\\beta\\neq\\gamma;\\\\\n    s \\beta d,\\text{ if }\\beta=\\gamma,\\\\\n    \\end{cases}\n    $$\n    where the term $d$ is the same it was added when updating the base aMana vector. \n")),(0,o.kt)("h4",{id:"pledging-the-amana-relative-to-a-transaction-with-timestamp-larger-than-the-last-reference-time"},"Pledging the aMana relative to a transaction with timestamp larger than the last reference time"),(0,o.kt)("p",null,"Suppose that the last reference time is $t-s$ and the transaction timestamp is $t$. The update must be done in three steps, always in the order specified below:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Base aMana update with respect to time"),". Suppose that the last base aMana is $\\text{Old","_","Base","_","aMana}$. We update all base aMana entries as follows:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"    $$\n    \\text{Base\\_aMana}(\\text{Node}_i) = e^{-\\gamma s}\\text{Old\\_Base\\_aMana}(\\text{Node}_i)\n    $$\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Base aMana pledging"),". Suppose that the new transaction consists of $m$ inputs $I_1, I_2, \\ldots, I_m$ of value $x_1, x_2, \\ldots, x_m$, respectively, and pledges aMana to a node $N$. We update the base aMana of node $N$ by adding to its base aMana the value")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"    $$\n    d=\\sum_{j=1}^{m}x_j(1-e^{-\\gamma \\delta_{j}})\n    $$ \n    where $\\delta_{j}>0$ is the difference between $t$ and the timestamps of the transaction that generated $I_j$ and $\\gamma$ is the decay factor. This value $d$ has to be temporarily stored, since it will be used in the aMana update.\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Updating the aMana with respect to time"),".  We update all aMana entries as follows:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"    $$\n    \\text{ aMana}(\\text{Node}_i)=\\begin{cases}  \n    e^{-\\beta s} \\text{Old\\_aMana}(\\text{Node}_i)+\\frac{e^{-\\gamma s}-e^{-\\beta s}}{(\\beta-\\gamma)e^{-\\gamma s}}    \\beta\\text{Base\\_aMana}(\\text{Node}_i),\\text{ if }\\beta\\neq\\gamma;\\\\\n    e^{-\\beta s} \\text{Old\\_aMana}(\\text{Node}_i)+s\\beta\\text{Base\\_aMana}(\\text{Node}_i),\\text{ if }\\beta=\\gamma,\\\\\n    \\end{cases}\n    $$\n\n    where $\\beta$ is the moving average parameter for the aMana and $\\gamma$ is the base aMana decay factor. Notice that, here, the value of $\\text{Base\\_aMana(Node}_i)$ used is the one already updated. \n")),(0,o.kt)("h4",{id:"updating-the-amana-to-a-time-larger-than-the-last-reference-time-without-any-new-amana-pledging"},"Updating the aMana to a time larger than the last reference time without any new aMana pledging."),(0,o.kt)("p",null,"Suppose that the last reference time is $t-s$ and new one is $t$. The update must be done in two steps, always in the order specified below:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Base aMana update with respect to time"),". Suppose that the outdated base aMana is $\\text{Old","_","Base","_","aMana}$. We update the base aMana entries as follows:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"    $$\n    \\text{Base\\_aMana}(\\text{Node}_i) = e^{-\\gamma s}\\text{Old\\_Base\\_aMana}(\\text{Node}_i)\n    $$\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Updating the aMana with respect to time"),". We update all the aMana entries as follows:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"    $$\n    \\text{aMana}(\\text{Node}_i)=\\begin{cases}  \n    e^{-\\beta s} \\text{Old\\_aMana}(\\text{Node}_i)+\\frac{e^{-\\gamma s}-e^{-\\beta s}}{(\\beta-\\gamma)e^{-\\gamma s}}    \\beta\\text{Base\\_aMana}(\\text{Node}_i),\\text{ if }\\beta\\neq\\gamma;\\\\\n    e^{-\\beta s} \\text{Old\\_aMana}(\\text{Node}_i)+s\\beta\\text{Base\\_aMana}(\\text{Node}_i),\\text{ if }\\beta=\\gamma,\\\\\n    \\end{cases}\n    $$\n    where $\\beta$ is the moving average parameter for the aMana and $\\gamma$ is the base aMana decay factor. Notice that, here, the value of $\\text{Base\\_aMana(Node}_i)$ used is the one already updated. \n")),(0,o.kt)("p",null,"The following data structures and functions must be defined:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"GetAccessMana()"),": returns a mapping between all known nodes and their access Mana, calculated at ",(0,o.kt)("inlineCode",{parentName:"p"},"currentTime")," (which means that the aMana is updated to ",(0,o.kt)("inlineCode",{parentName:"p"},"currentTime")," when this function is called).")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"UpdateaMana(transaction)"),": whenever a transaction ",(0,o.kt)("inlineCode",{parentName:"p"},"transaction")," is added to the ledger state, it updates the aMana vector in order to add the aMana relative to ",(0,o.kt)("inlineCode",{parentName:"p"},"transaction")," and to the (possibly) new reference time."))),(0,o.kt)("h2",{id:"535-initialization"},"5.3.5. Initialization"),(0,o.kt)("p",null,"The Mana is an extension of the ledger state, hence its calculation depends on the ledger state perception of the node. Snapshotting is the mechanism that stores older ledger states and prunes unnecessary messages. Together with the ledger state, aMana and cMana vectors (and the reference time relative to them) are also saved, since a certain ledger state reflects a certain aMana and cMana distribution in the network. Thus, when a node joins the network, it will query other nodes to get their snapshot file, containing a ",(0,o.kt)("inlineCode",{parentName:"p"},"aMana Snapshot Vector"),", a ",(0,o.kt)("inlineCode",{parentName:"p"},"cMana Snapshot Vector"),", and two ",(0,o.kt)("inlineCode",{parentName:"p"},"ACMS")," (one for each of the last two snapshotted epochs) that will be used as initialization data. "),(0,o.kt)("h2",{id:"536-algorithm"},"5.3.6. Algorithm"),(0,o.kt)("h3",{id:"5361-parameter-values"},"5.3.6.1. Parameter Values"),(0,o.kt)("p",null,"The following parameters will be used by default, and all nodes must know them. We do not have explicit rules to punish nodes that clearly do not use these parameters, but we expect that they would be eventually ignored, due to other implicit mechanisms. For instance, even if the Mana vectors of a certain node are significantly different from the other nodes' view (causing a divergence from the majority's opinion in the voting protocol), with a very high probability its opinion will not affect the final outcome of the voting. For other modules (like congestion control), a node with a significantly different perception of Mana will be blacklisted and will not harm the network. Thus, the nodes have plenty of incentives to follow the rules."),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"Name"),(0,o.kt)("th",{parentName:"tr",align:"center"},"Type"),(0,o.kt)("th",{parentName:"tr",align:null},"Description"),(0,o.kt)("th",{parentName:"tr",align:null},"Observation"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"DECAY")),(0,o.kt)("td",{parentName:"tr",align:"center"},"float"),(0,o.kt)("td",{parentName:"tr",align:null},"decay factor for base aMana"),(0,o.kt)("td",{parentName:"tr",align:null},"Called $\\gamma$ in the last sections. For a half life of ~6 hours we need $\\gamma=0.00192541 \\frac{1}{\\text{min}}$.")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"C_MANA_EMA_COEFF")),(0,o.kt)("td",{parentName:"tr",align:"center"},"float"),(0,o.kt)("td",{parentName:"tr",align:null},"moving average factor for the cMana"),(0,o.kt)("td",{parentName:"tr",align:null},"Called $\\alpha$ in the last sections. Set as the same value as $\\gamma$.")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"A_MANA_EMA_COEFF")),(0,o.kt)("td",{parentName:"tr",align:"center"},"float"),(0,o.kt)("td",{parentName:"tr",align:null},"moving average factor for the aMana"),(0,o.kt)("td",{parentName:"tr",align:null},"Called $\\beta$ in the last sections. Set as the same value as $\\gamma$.")))),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Table 5.3.2:")," List of Parameters."),(0,o.kt)("h3",{id:"5362-local-variables-and-built-in-functions"},"5.3.6.2. Local Variables and Built-in Functions"),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"Name"),(0,o.kt)("th",{parentName:"tr",align:"center"},"Type"),(0,o.kt)("th",{parentName:"tr",align:null},"Description"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"object.cManaNode")),(0,o.kt)("td",{parentName:"tr",align:"center"},"nodeID"),(0,o.kt)("td",{parentName:"tr",align:null},"Id of the node to which ",(0,o.kt)("inlineCode",{parentName:"td"},"object"),"'s cMana was pledged")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"object.amount")),(0,o.kt)("td",{parentName:"tr",align:"center"},"double"),(0,o.kt)("td",{parentName:"tr",align:null},"Amount moved by ",(0,o.kt)("inlineCode",{parentName:"td"},"object"))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"object.aManaNode")),(0,o.kt)("td",{parentName:"tr",align:"center"},"nodeID"),(0,o.kt)("td",{parentName:"tr",align:null},"Id of the node to which ",(0,o.kt)("inlineCode",{parentName:"td"},"object"),"'s aMana was pledged")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"transaction.inputs")),(0,o.kt)("td",{parentName:"tr",align:"center"},"list of inputs IDs"),(0,o.kt)("td",{parentName:"tr",align:null},"List of inputs consumed by ",(0,o.kt)("inlineCode",{parentName:"td"},"transaction"))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"transaction.time")),(0,o.kt)("td",{parentName:"tr",align:"center"},"time"),(0,o.kt)("td",{parentName:"tr",align:null},"Timestamp of ",(0,o.kt)("inlineCode",{parentName:"td"},"transaction"))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"nodes")),(0,o.kt)("td",{parentName:"tr",align:"center"},"list of nodeIDs"),(0,o.kt)("td",{parentName:"tr",align:null},"List of known nodes.")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"epoch.finalTime")),(0,o.kt)("td",{parentName:"tr",align:"center"},"time"),(0,o.kt)("td",{parentName:"tr",align:null},"Final time of ",(0,o.kt)("inlineCode",{parentName:"td"},"epoch"))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"epoch.initialTime")),(0,o.kt)("td",{parentName:"tr",align:"center"},"time"),(0,o.kt)("td",{parentName:"tr",align:null},"Initial time of ",(0,o.kt)("inlineCode",{parentName:"td"},"epoch"))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"epoch.transactions")),(0,o.kt)("td",{parentName:"tr",align:"center"},"list of TxIds"),(0,o.kt)("td",{parentName:"tr",align:null},"Set of transactions with timestamps in the interval ",(0,o.kt)("inlineCode",{parentName:"td"},"[epoch.initialTime,epoch.finalTime)"))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"input.time")),(0,o.kt)("td",{parentName:"tr",align:"center"},"time"),(0,o.kt)("td",{parentName:"tr",align:null},"Timestamp of the transaction that generated the output relative to ",(0,o.kt)("inlineCode",{parentName:"td"},"input"))))),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Table 5.3.3:")," Local Variables and Built-in Functions."),(0,o.kt)("h2",{id:"5363-pseudocode---cmana-update"},"5.3.6.3. Pseudocode - cMana Update"),(0,o.kt)("p",null,"In this section, for the sake of clarity, we introduce an example of code of the functions defined above. "),(0,o.kt)("h4",{id:"updatebasecmanatrtransaction"},(0,o.kt)("inlineCode",{parentName:"h4"},"UpdateBasecManaTr(transaction)")),(0,o.kt)("p",null,"The function ",(0,o.kt)("inlineCode",{parentName:"p"},"UpdateBasecManaTr(transaction)")," updates the vector ",(0,o.kt)("inlineCode",{parentName:"p"},"basecMana"),", pledging and revoking the base cMana relative to a transaction ",(0,o.kt)("inlineCode",{parentName:"p"},"transaction"),". "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-vbnet"},"FUNCTION UpdateBasecManaTr(transaction)\n    basecMana[transaction.cManaNode] = basecMana[transaction.cManaNode]+transaction.amount \n    FOR input in transaction.inputs\n        basecMana[input.cManaNode] = basecMana[input.cManaNode]-input.amount\n")),(0,o.kt)("h4",{id:"updatecmanatimeepoch"},(0,o.kt)("inlineCode",{parentName:"h4"},"UpdatecManaTime(epoch)")),(0,o.kt)("p",null,"The function ",(0,o.kt)("inlineCode",{parentName:"p"},"UpdatecManaTime(epoch)")," updates the vector ",(0,o.kt)("inlineCode",{parentName:"p"},"cMana"),", changing its reference time from the end of ",(0,o.kt)("inlineCode",{parentName:"p"},"epoch-1")," to the end of ",(0,o.kt)("inlineCode",{parentName:"p"},"epoch"),". "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-vbnet"},"FUNCTION UpdatecManaTime(epoch)\n    n = epoch.finalTime-epoch.initialTime\n    FOR node in nodes\n        cMana[node] = exp(-C_MANA_EMA_COEFF*n)*cMana[node]\n                        +(1-exp(-C_MANA_EMA_COEFF*n))*basecMana[node]\n")),(0,o.kt)("h4",{id:"updatecmanatrepochtransaction"},(0,o.kt)("inlineCode",{parentName:"h4"},"UpdatecManaTr(epoch,transaction)")),(0,o.kt)("p",null,"The function ",(0,o.kt)("inlineCode",{parentName:"p"},"UpdatecManaTr(epoch,transaction)")," updates the vector ",(0,o.kt)("inlineCode",{parentName:"p"},"cMana"),", pledging and revoking the cMana relative to a transaction ",(0,o.kt)("inlineCode",{parentName:"p"},"transaction"),". "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-vbnet"},"FUNCTION UpdatecManaTr(epoch,transaction)\n    n = epoch.finalTime - transaction.time\n    FOR node in nodes\n        IF basecMana[node] != basecManaOld[node]\n            cMana[node] = cMana[node]+(1-(1-C_MANA_EMA_COEFF)**n)*(basecMana[node]-basecManaOld[node])\n")),(0,o.kt)("h4",{id:"updatecmanaepoch"},(0,o.kt)("inlineCode",{parentName:"h4"},"UpdatecMana(epoch)")),(0,o.kt)("p",null,"The function ",(0,o.kt)("inlineCode",{parentName:"p"},"UpdatecMana(epoch)")," updates the vectors ",(0,o.kt)("inlineCode",{parentName:"p"},"cMana")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"basecMana"),", from the end of ",(0,o.kt)("inlineCode",{parentName:"p"},"epoch-1")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"epoch"),", pledging and revoking the base cMana and cMana relative to all the relevant transactions. "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-vbnet"},"FUNCTION UpdatecMana(epoch):\n    UpdatecManaTime(epoch)\n    IF epoch.transactions != NULL:\n        FOR transaction in epoch.transactions:\n            basecManaOld = basecMana\n            UpdateBasecManaTr(transaction)\n            UpdatecManaTr(epoch,transaction)\n")),(0,o.kt)("h3",{id:"5364-pseudocode---amana-update"},"5.3.6.4. Pseudocode - aMana Update"),(0,o.kt)("p",null,"In this section, for the sake of clarity, we introduce an example of code of the functions defined above. "),(0,o.kt)("h4",{id:"updatebaseamanatimet"},(0,o.kt)("inlineCode",{parentName:"h4"},"UpdateBaseaManaTime(t)")),(0,o.kt)("p",null,"The function ",(0,o.kt)("inlineCode",{parentName:"p"},"UpdateBaseaManaTime(t)")," updates the vector ",(0,o.kt)("inlineCode",{parentName:"p"},"baseaMana"),", changing its reference time from ",(0,o.kt)("inlineCode",{parentName:"p"},"lastUpdateTime")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"t"),". "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-vbnet"},"FUNCTION UpdateBaseaManaTime(t)\n    n = t-lastUpdateTime\n    FOR each node i\n        baseaMana[i] = baseaMana[i]*exp(-DECAY*n)  \n")),(0,o.kt)("h4",{id:"updateamanatimet"},(0,o.kt)("inlineCode",{parentName:"h4"},"UpdateaManaTime(t)")),(0,o.kt)("p",null,"The function ",(0,o.kt)("inlineCode",{parentName:"p"},"UpdateaManaTime(t)")," updates the vector ",(0,o.kt)("inlineCode",{parentName:"p"},"aMana"),", changing its reference time from ",(0,o.kt)("inlineCode",{parentName:"p"},"lastUpdateTime")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"t"),". "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-vbnet"},"FUNCTION UpdateaManaTime(t)\n    n = t-lastUpdateTime\n    IF DECAY != A_MANA_EMA_COEFF\n        FOR each node i\n            aMana[i] = exp(-A_MANA_EMA_COEFF*n)*aMana[i]+(1-exp((DECAY-A_MANA_EMA_COEFF)*n))/(A_MANA_EMA_COEFF-DECAY))*A_MANA_EMA_COEFF*baseaMana[i]\n    ELSE       \n        FOR each node i\n            aMana[i] = exp(-A_MANA_EMA_COEFF*n)*aMana[i]+ DECAY*A_MANA_EMA_COEFF*baseaMana[i]            \n")),(0,o.kt)("h4",{id:"updatebaseamanatrtransaction"},(0,o.kt)("inlineCode",{parentName:"h4"},"UpdateBaseaManaTr(transaction)")),(0,o.kt)("p",null,"The function ",(0,o.kt)("inlineCode",{parentName:"p"},"UpdateBaseaManaTr(t,transaction)")," updates the vector ",(0,o.kt)("inlineCode",{parentName:"p"},"baseaMana"),", pledging the base aMana relative to a transaction ",(0,o.kt)("inlineCode",{parentName:"p"},"transaction"),". "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-vbnet"},"FUNCTION UpdateBaseaManaTr(transaction)\n    FOR input in transaction.inputs\n        baseaMana[transaction.aManaNode] = baseaMana[transaction.aManaNode]+exp(-DECAY*(MAX(transaction.time,lastUpdateTime)-transaction.time))*input.amount*(1-exp(-DECAY*(transaction.time-input.time))) \n")),(0,o.kt)("h4",{id:"updateamanatrtransaction"},(0,o.kt)("inlineCode",{parentName:"h4"},"UpdateaManaTr(transaction)")),(0,o.kt)("p",null,"The function ",(0,o.kt)("inlineCode",{parentName:"p"},"UpdateaManaTr(transaction)")," updates the vector ",(0,o.kt)("inlineCode",{parentName:"p"},"aMana"),", pledging the aMana relative to a transaction ",(0,o.kt)("inlineCode",{parentName:"p"},"transaction"),". "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-vbnet"},"FUNCTION UpdateaManaTr(transaction):\n    n = lastUpdateTime-transaction.time\n    IF DECAY != A_MANA_EMA_COEFF\n        aMana[transaction.aManaNode] = aMana[transaction.aManaNode]+(exp(-DECAY*n)-exp(-A_MANA_EMA_COEFF*n))/(A_MANA_EMA_COEFF-DECAY))*A_MANA_EMA_COEFF*(baseaMana[transaction.aManaNode]-baseaManaOld[transaction.aManaNode])\n    ELSE\n        aMana[aManaNode(transaction)] = aMana[transaction.aManaNode]+exp(-DECAY*n)*DECAY*A_MANA_EMA_COEFF*(baseaMana[transaction.aManaNode]-baseaManaOld[transaction.aManaNode])\n\n")),(0,o.kt)("h4",{id:"updateamanatransaction"},(0,o.kt)("inlineCode",{parentName:"h4"},"UpdateaMana(transaction)")),(0,o.kt)("p",null,"The function ",(0,o.kt)("inlineCode",{parentName:"p"},"UpdateaMana(transaction)")," updates the vectors ",(0,o.kt)("inlineCode",{parentName:"p"},"aMana")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"baseaMana"),", from ",(0,o.kt)("inlineCode",{parentName:"p"},"lastUpdateTime")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"MAX(lastUpdateTime, transaction.time)"),", pledging the base aMana and aMana relative to ",(0,o.kt)("inlineCode",{parentName:"p"},"transaction"),". "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-vbnet"},"FUNCTION UpdateaMana(transaction):\n    # if the tx is not old, add it and update the vector to t   \n    IF transaction.time > lastUpdateTime:\n        UpdateBaseaManaTime(transaction.time)\n        UpdateaManaTime(transaction.time)\n        UpdateBaseaManaTr(transaction)\n        lastUpdateTime  = transaction.time        \n    # add a transaction in the past    \n    IF transaction.time < lastUpdateTime:\n        baseaManaOld = baseaMana\n        UpdateBaseaManaTr(transaction)\n        UpdateaManaTr(transaction)\n")))}m.isMDXComponent=!0}}]);