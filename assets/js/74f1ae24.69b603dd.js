(self.webpackChunkdoc_ops=self.webpackChunkdoc_ops||[]).push([[364],{3905:function(e,t,n){"use strict";n.d(t,{Zo:function(){return p},kt:function(){return m}});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=c(n),m=i,u=d["".concat(l,".").concat(m)]||d[m]||h[m]||r;return n?a.createElement(u,o(o({ref:t},p),{},{components:n})):a.createElement(u,o({ref:t},p))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,o[1]=s;for(var c=2;c<r;c++)o[c]=n[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},2228:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return c},toc:function(){return p},default:function(){return d}});var a=n(2122),i=n(9756),r=(n(7294),n(3905)),o=["components"],s={},l="6.4 Approval Weight and Finality",c={unversionedId:"6.4 Finalization",id:"6.4 Finalization",isDocsHomePage:!1,title:"6.4 Approval Weight and Finality",description:"6.4.1 Introduction",source:"@site/docs/6.4 Finalization.md",sourceDirName:".",slug:"/6.4 Finalization",permalink:"/IOTA-2.0-Research-Specifications/docs/6.4 Finalization",editUrl:"https://github.com/iotaledger/IOTA-2.0-Research-Specifications/edit/master/website/docs/6.4 Finalization.md",version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"6.3 Fast Probabilistic Consensus",permalink:"/IOTA-2.0-Research-Specifications/docs/6.3 Fast Probabilistic Consensus"},next:{title:"6.5 Distributed Random Number Generator",permalink:"/IOTA-2.0-Research-Specifications/docs/6.5 dRNG"}},p=[{value:"6.4.1 Introduction",id:"641-introduction",children:[]},{value:"6.4.2 Definitions",id:"642-definitions",children:[]},{value:"6.4.2 Approval Weight",id:"642-approval-weight",children:[]},{value:"6.4.3 Finality",id:"643-finality",children:[]},{value:"6.4.4 Markers Application to Finality",id:"644-markers-application-to-finality",children:[]},{value:"6.4.5 Liked and monotonically liked",id:"645-liked-and-monotonically-liked",children:[]}],h={toc:p};function d(e){var t=e.components,n=(0,i.Z)(e,o);return(0,r.kt)("wrapper",(0,a.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"64-approval-weight-and-finality"},"6.4 Approval Weight and Finality"),(0,r.kt)("h2",{id:"641-introduction"},"6.4.1 Introduction"),(0,r.kt)("p",null,"This part of the specifications defines the ",(0,r.kt)("em",{parentName:"p"},"Approval Weight")," tool, which allows the notion of ",(0,r.kt)("em",{parentName:"p"},"Finality"),".  As every node might have slightly different perceptions of the Tangle at a given time, such a notion is necessary to guarantee consensus on the Tangle and its ledger state. "),(0,r.kt)("p",null,"The intuition behind the approval weight of a given message is that the more influential messages are approving a given message, the more trustworthy such a message will be for the other nodes, and thus the higher the probability that this message branch will be included in the main branch, i.e., will update the ledger state permanently. More details on branches and ledger state may be found in ","[Section 5.2 - Ledger State]","(./5.2 Ledger State.md)."),(0,r.kt)("p",null,"The approval weight tool is inspired by the confirmation confidence tool, initially defined in the legacy ",(0,r.kt)("a",{parentName:"p",href:"https://assets.ctfassets.net/r1dr6vzfxhev/2t4uxvsIqk0EUau6g2sw0g/45eae33637ca92f85dd9f4a3a218e1ec/iota1_4_3.pdf"},"Tangle whitepaper"),". However, unlike confirmation confidence which only considered the weight of the future cone of a message to decide if it was final, the approval weight now considers the proportion of approving active consensus Mana, making the protocol more robust against spam and Sybil attacks. "),(0,r.kt)("p",null,"The Approval Weight and Finality specification depends on the following specifications:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"[4.7 - Markers]","(./4.7 Markers.md)"),(0,r.kt)("li",{parentName:"ul"},"[5.2 - Ledger State]","(./5.2 Ledger State.md)"),(0,r.kt)("li",{parentName:"ul"},"[5.3 - Mana]","(./5.3 Mana.md)"),(0,r.kt)("li",{parentName:"ul"},"[6.1 - Object of Consensus]","(./6.1 Objects of Consensus.md)"),(0,r.kt)("li",{parentName:"ul"},"[6.3 - Fast Probabilistic Consensus]","(./6.3 Fast Probabilistic Consensus.md)")),(0,r.kt)("h2",{id:"642-definitions"},"6.4.2 Definitions"),(0,r.kt)("p",null,"To define approval weight, we first need to understand what it means to support a message, we require some concepts of branches from ","[Section 5.2 - Ledger State]","(./5.2 Ledger State.md)."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Conflict:")," Two transactions conflict if they consume the same output. A conflict is a transaction that conflicts with another transaction. A transaction $x$ conflicts with a branch $B$ if the set of conflicts in $x$'s UTXO past cone and the set of conflicts in $B$ conflict.  "),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Node Approval:")," We say that a node approves a given message $x$ if it has issued a message $y$ in the strong future cone of $x$.  A node approves a transaction if it approves some message containing that transaction.  "),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Conflict Supporter:")," A node supports a conflict if:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"It issued a message approving a message containing that transaction."),(0,r.kt)("li",{parentName:"ul"},"It has not issued a message on a conflicting branch with a more recent timestamp or with the same timestamp but greater message ID.  "))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Branch Supporter:")," A node supports a branch if it supports all of its conflicts.  Equivalently, the supporters of a branch are the intersection of all the supporters of its conflicts.  "),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Message Supporter:")," The supporters of a message is the intersection of the approvers of the message, and the supporter of its branch. "),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Active Consensus Mana:"),"  The active consensus Mana is defined as the sum of the consensus Mana of all nodes that issued messages during the second last complete epoch ",(0,r.kt)("inlineCode",{parentName:"li"},"cepoch-2"),", before the current epoch ",(0,r.kt)("inlineCode",{parentName:"li"},"cepoch"),".  We say that a node that has not issued a message within that epoch has 0 active consensus mana. See ","[Section 5.3 - Mana]","(./5.3 Mana.md).")),(0,r.kt)("p",null,"To be clear a node cannot be a  supporter of two conflicting transactions.  If it approves two messages with conflicting transactions,  it supports the one it more recently references (with respect to the timestamp). In the case where the node more recently supported an incompatible message in a different conflict set, then it doesn't support any of the messages.  When a new message is booked, the node goes to the message's branch in the branch DAG and walks through the branch's history giving support to all the conflicts in its past cone and revoking support from conflicting branches.  "),(0,r.kt)("p",null,(0,r.kt)("img",{parentName:"p",src:"https://user-images.githubusercontent.com/11289354/112409357-518e9480-8d54-11eb-8a40-19f4ab33ea35.png",alt:"ApprovalWeight"}),"\n",(0,r.kt)("strong",{parentName:"p"},"Image 6.4.1:")," An example of how the propagation will look like. "),(0,r.kt)("p",null,"In Image 6.4.1, the green node issued ",(0,r.kt)("strong",{parentName:"p"},"message 1")," and attached it to ",(0,r.kt)("inlineCode",{parentName:"p"},"Branch 1.1 + Branch 4.1.1"),". Thus, green node is a supporter of ",(0,r.kt)("inlineCode",{parentName:"p"},"Branch 1.1 + Branch 4.1.1"),", and it's also a supporter of the parent branches, which are (from top to bottom) ",(0,r.kt)("inlineCode",{parentName:"p"},"Branch 4.1.1"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Branch 1.1"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Branch 4.1"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Branch 1"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"Branch 4"),"."),(0,r.kt)("p",null,"Later, the green node issued ",(0,r.kt)("strong",{parentName:"p"},"message 2")," and attached it to ",(0,r.kt)("inlineCode",{parentName:"p"},"Branch 4.1.2"),". This makes the green node a supporter of ",(0,r.kt)("inlineCode",{parentName:"p"},"Branch 4.1.2"),", however, ",(0,r.kt)("inlineCode",{parentName:"p"},"Branch 4.1.1")," is conflicting with ",(0,r.kt)("inlineCode",{parentName:"p"},"Branch 4.1.2"),", which makes green node not a supporter of ",(0,r.kt)("inlineCode",{parentName:"p"},"Branch 4.1.1"),", and therefore the support to ",(0,r.kt)("inlineCode",{parentName:"p"},"Branch 1.1 + Branch 4.1.1")," is removed as well. "),(0,r.kt)("p",null,"Finally, green nodes issued ",(0,r.kt)("strong",{parentName:"p"},"message 3"),", which is in ",(0,r.kt)("inlineCode",{parentName:"p"},"Branch 2"),". Now the green node is a supporter of ",(0,r.kt)("inlineCode",{parentName:"p"},"Branch 2"),", and no longer a supporter of ",(0,r.kt)("inlineCode",{parentName:"p"},"Branch 1"),", since ",(0,r.kt)("inlineCode",{parentName:"p"},"Branch 1")," is conflicting with ",(0,r.kt)("inlineCode",{parentName:"p"},"Branch 2"),". Note that, this supporter removal will propagate to child branches. Thus, green node is removed from ",(0,r.kt)("inlineCode",{parentName:"p"},"Branch 1.1"),". "),(0,r.kt)("p",null,"Since ",(0,r.kt)("inlineCode",{parentName:"p"},"Branch 3"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"4"),", and both of their child branches have nothing to do with this attachment, the supporter status remains. "),(0,r.kt)("h2",{id:"642-approval-weight"},"6.4.2 Approval Weight"),(0,r.kt)("p",null,"The approval weight of a conflict (resp. branch or message) is the dot product of the vectors of supporters and the normalized consensus Mana vector (see ","[Section 5.3 - Mana]","(./5.3 Mana.md)). Equivalently, the approval weight is the proportion of active consensus Mana that belongs to the supporters of the conflict (resp. branch or message)."),(0,r.kt)("p",null,"We will use $\\text{AW}(x)$ to represent the approval weight of a message or branch $x$. There are several important facts to state about approval weight:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Approval weight range"),": The approval weight is always between $0$ and $1$, and thus can be expressed as a percentage.  "),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Approval weight equivalency"),": For a conflict $x$ attached once in a message $m$, the following are the same: the approval weight of $x$, the approval weight of the conflict branch defined by $x$, and the approval weight of the message $m$. "),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Tangle Monotonicity:")," The approval weight of a message is smaller than its past cone, i.e. if message $x$ approves message $y$, then $\\text{AW}(y)\\geq \\text{AW}(x)$."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Branch Monotonicity:")," The approval weight of a branch is greater than the branches in pastcone on the branch DAG, i.e., if branch $B$ contains branch $C$, then $\\text{AW}(C)\\geq \\text{AW}(B)$."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"No Time Monotonicity:")," The approval weight of a fixed message or branch $x$ does not necessarily grow with time because of the nodes' active consensus Mana fluctuates and support can be revoked."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Approval weight inequalities:"),"  For any message $m$ and its branch $B$, we have $\\text{AW}(B)\\geq \\text{AW}(m)$. Similarly, for any conflict $x$ within a branch, $\\text{AW}(x)\\geq \\text{AW}(B)$, since any supporter of the branch $B$ is a supporter of $x$.")),(0,r.kt)("p",null,"Observe that the non-monotonicity on time is actually desirable, as otherwise it would not be possible to orphan malicious or non-preferred conflicting messages.  "),(0,r.kt)("h2",{id:"643-finality"},"6.4.3 Finality"),(0,r.kt)("p",null,'Finality in IOTA 2.0 must always be considered as probabilistic, in the sense that a final message is included in the ledger with a very high probability. Two desired properties in a finality criterion are a fast confirmation rate and a high probability of non-reversibility. We use interchangeably the terms "finality" and "confirmation". We now present the proposed criterion for finality. '),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Branch Finality/Confirmation:")," A branch $B$ is considered finalized (or confirmed) if its approval weight is at least $0.5$ higher than any conflicting branch.  The master branch is always finalized.  "),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Message Finality/Confirmation:")," A message $m$ is considered finalized (or confirmed) if $\\text{AW}(m)>0.5$ and its branch is finalized. "),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Transaction Finality/Confirmation:")," A transaction is considered finalized (or confirmed) if both its message and its branch are final (confirmed). ")),(0,r.kt)("p",null,"Because of the Tangle monotonicity property, if a message is finalised, its entire past cone is finalised as well."),(0,r.kt)("h2",{id:"644-markers-application-to-finality"},"6.4.4 Markers Application to Finality"),(0,r.kt)("p",null,"The approval weight of the branch is updated whenever the supporters are updated.  However, it is impractical to store the supporters of every message, and even calculating it on demand is unfeasible, since the computational cost of doing a future cone search to determine its approvers is immense.  To ease this calculation, we make use of the markers tool, see ","[Section 4.7 - Markers]","(./4.7 Markers.md), to approximate the approval of a message weight in an efficient way. "),(0,r.kt)("p",null,"Markers are basically chains of indexed messages, and each message is associated with the most recent marker it approves and the oldest marker that approves it. When a new message arrives, the approvers of each marker can be updated by traversing the much smaller marker DAG and, from the Tangle monotonicity property, we know that if the marker achieve a certain value of approval weight, the message it approves will have a higher value."),(0,r.kt)("p",null,"Using those properties, we can define a lightweight criterion which we call ",(0,r.kt)("strong",{parentName:"p"},"Markers Application to Finality:")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The supporters of any mark are tracked, which is made easier by the metadata associated to each marker, see ","[Section 4.7 - Markers]","(./4.7 Markers.md)."),(0,r.kt)("li",{parentName:"ul"},'If any marker reaches message confirmation, we give the "confirmed" status to all messages in its past cone, and hence transaction confirmation to all transactions it may contain.'),(0,r.kt)("li",{parentName:"ul"},"If a tracked marker reaches age ",(0,r.kt)("inlineCode",{parentName:"li"},"FinalityMaxAge"),' without achieving confirmation, it will receive the status "Orphaned".')),(0,r.kt)("h2",{id:"645-liked-and-monotonically-liked"},"6.4.5 Liked and monotonically liked"),(0,r.kt)("p",null,'Via finality, the approval weight is also used in conjunction with the fast probabilistic consensus (FPC) and to determine which branches should be considered for tip selection.  To do this we have the concept  of branches and conflicts being "liked".  '),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Liked conflict:")," A conflict is liked (or individually liked) if either:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The opinion of the transaction is ",(0,r.kt)("inlineCode",{parentName:"li"},"true")," and the ",(0,r.kt)("inlineCode",{parentName:"li"},"level")," is either 2 or 3 (i.e. FPC has terminated with ",(0,r.kt)("inlineCode",{parentName:"li"},"liked")," status, see ","[Section 6.1 - Objects of Consensus]","(./6.1 Objects of Consensus.md)) AND it does not conflict with a finalized transaction.",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The conflict is finalized."))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Individually liked conflict branch:")," A conflict branch is individually liked if the conflict defining it is liked."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Monotonically liked branch:")," A branch is monotonically liked if all of its conflicts are liked.  Equivalently, a branch is monotonically liked if all of its conflict branches in its branch past cone are individually liked.")),(0,r.kt)("p",null,'FPC initially determines which conflicts are liked.  However, nodes that are syncing and missed the FPC voting will default to the conflicts which are finalised.  Decisions about each conflict set are carried out by FPC individually and so we separate between "individually liked" and "monotonically liked".\nBranches that are monotonically liked have their entire history liked and can be included in the strong past cone of messages.  Monotonically like branch IDs will thus receive more supporters and thus eventually become finalised.  '),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Note"),': Once a branch gets confirmed, the conflicting ones receive the status "Rejected".'))}d.isMDXComponent=!0}}]);